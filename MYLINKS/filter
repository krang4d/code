Операции с файлами и фильтрация
Основная часть работы в командной строке ведётся с файлами. В этом разделе мы рассмотрим, как просматривать и фильтровать содержимое файлов, извлекать из файлов нужную информацию при помощи одной команды и сортировать их содержимое.

cat, tail, head, tee: Команды для вывода содержимого файлов

Эти команды имеют почти один и тот же синтаксис: имя_команды [опции] [файл(ы)], и могут быть использованы в каналах. Все они используются для вывода части файла согласно определенным критериям.

Утилита cat объединяет файлы и выводит результат на стандартный вывод. Это одна из наиболее широко используемых команд. Вы можете использовать:

 # cat /var/log/mail/info
для вывода, например, содержимого файла с журналом почтового демона на стандартный вывод [14]. Команда cat имеет очень полезную опцию (-n), которая позволяет вам выводить номера строк.

Некоторые файлы, типа журналов демонов (если они запущены) обычно имеют довольно большой размер [15] и полный их вывод на экран будет не очень полезным. Часто вам нужно увидеть только несколько строк из файла. Для этого вы можете воспользоваться командой tail. Следующая команда выведет (по умолчанию) последние 10 строк из файла /var/log/mail/info:

 # tail /var/log/mail/info
Вы можете использовать опцию -n для вывода последних N строк файла. Например, для вывода последних 2-х строк наберите:

 # tail -n2 /var/log/mail/info
Команда head похожа на tail, но она выводит первые строки файла. Следующая команда выведет (по умолчанию) первые 10 строк файла /var/log/mail/info:

 # head /var/log/mail/info
Как и в случае с tail вы можете использовать опцию -n для указания количества выводимых строк. Например, для вывода первых 2-х строк наберите:

 # head -n2 /var/log/mail/info
Также вы можете использовать эти две команды совместно. Например, если вы хотите увидеть только строки 9 и 10, вы можете воспользоваться командой, в которой head выберет первые 10 строк из файла и передаст их по каналу в команду tail.

 # head /var/log/mail/info | tail -n2
Затем вторая часть команды отберет последние 2 строки и выведет их на экран. Таким же способом вы можете выбрать 20-ю от конца файла строку:

 # tail -n20 /var/log/mail/info |head -n1
В этом примере мы говорим команде tail выбрать последние 20 строк файла и передать их по каналу в head. Затем команда head выводит на экран первую строку из полученных данных.

Допустим, что результат последнего примера нам нужно одновременно вывести на экран и сохранить его в файл results.txt. В этом нам может поможет утилита tee. Ее синтаксис:

 tee [опции] [файл]
Теперь мы можем изменить предыдущую команду следующим образом:

 # tail -n20 /var/log/mail/info |head -n1|tee results.txt
Давайте рассмотрим еще один пример. Нам нужно выбрать последние 20 строк, сохранить их в файл results.txt, а на экран вывести только первую из них. Тогда мы должны ввести следующее:

 # tail -n20 /var/log/mail/info |tee results.txt |head -n1
У команды tee есть полезная опция (-a), которая позволяет вам дописать данные в конец существующего файла.

Давайте вернемся назад к команде tail. Такие файлы как журналы обычно динамически изменяются, т.к. демон постоянно добавляет в них отчет о совершенных действиях или событиях. Поэтому, если вам нужно наблюдать за изменениями в лог-файле в режиме реального времени, тогда вам нужно воспользоваться преимуществами опции -f:

 # tail -f /var/log/mail/info
В этом случае все изменения в файле /var/log/mail/info будут немедленно выводиться на экран. Использование команды tail с опцией -f весьма полезно, когда вам нужно знать, как работает ваша система. Например, наблюдая за файлом журнала /var/log/messages, вы сможете всегда получать обновленную информацию о системных сообщенях и различных демонах.

В следующем разделе мы рассмотрим, как можно использовать утилиту grep в качестве фильтра для отделения сообщений Postfix от сообщений других служб.

grep: Поиск строк в файлах

Ни имя команды, ни ее аббревиатура (“General Regular Expression Parser” - синтаксический анализатор общих регулярных выражений) не слишком интуитивны, но ее действие и ее использование довольно просты для понимания: grep выполняет поиск в одном или нескольких файлах по шаблону, заданному в качестве аргумента. Ее синтаксис:

grep [опции] <шаблон> [один или более файлов]
Если указано несколько файлов, в отображаемом результате их имена будут выводиться перед каждой найденной строкой. Для предотвращения вывода этих имен используйте опцию -h; используйте опцию -l для вывода только имен файлов с найденными совпадениями. Шаблон - это регулярное выражение, хотя в большинстве случаев он состоит просто из одного слова. Наиболее часто используемые опции:

-i: поиск без учета регистра (т.е. игнорирование разницы между верхним и нижним регистром);

-v: обратный поиск. Вывод строк, которые не соответствуют шаблону;

-n: вывод номера строки для каждой из найденных строк;

-w: сообщает grep'у, что шаблон должен совпадать со всем словом.

Итак, давайте теперь вернемся к анализу лог-файла почтового демона. Нам необходимо найти все строки в файле /var/log/mail/info, содержащие шаблон “postfix”. Для этого мы вводим такую команду:

 # grep postfix /var/log/mail/info
Команда grep может быть использована в канале. Так мы можем получить такой же результат, что и в предыдущем примере, при помощи следующего:

 # cat /var/log/mail/info | grep postfix 
Если нам нужно найти все строки, не содержащие шаблона “postfix”, нам надо будет воспользоваться опцией -v:

 # grep -v postfix /var/log/mail/info
Давайте предположим, что нам необходимо найти все сообщения об успешно отправленных письмах. В этом случае мы должны отфильтровать все строки, добавленные почтовым демоном в файл журнала (содержащие шаблон “postfix”), и они должны содержать сообщение об успешной отправке (“status=sent”):

 # grep postfix /var/log/mail/info |grep status=sent
В этом случае команда grep использована дважды. Это разрешается, но не совсем красиво. Мы можем получить тот же результат при помощи утилиты fgrep. Сначала нам нужно создать файл, содержащий шаблоны, записанные в столбик. Такой файл может быть создан следующим образом (мы используем patterns.txt в качестве имени файла):

 # echo -e 'status=sent\npostfix' >./patterns.txt
Затем мы вызываем следующую команду, в которой мы используем файл patterns.txt со списком шаблонов и утилиту fgrep вместо “двойного вызова” команды grep:

 # fgrep -f ./patterns.txt /var/log/mail/info
Файл ./patterns.txt может содержать сколько угодно шаблонов. Каждый из них должен быть введен в виде одной строки. Например, для выборки сообщений о письмах, успешно отправленных на адрес peter@mandrakesoft.com, достаточно будет добавить адрес этого электронного ящика в наш файл ./patterns.txt, выполнив следующую команду:

 # echo 'peter@mandrakesoft.com' >>./patterns.txt
Понятное дело, что вы можете комбиноровать команду grep с tail и head. Если нам нужно найти сообщения о предпоследнем электроном письме, отправленном на адрес peter@mandrakesoft.com, мы используем:

 # fgrep -f ./patterns.txt /var/log/mail/info | tail -n2 | head -n1
Здесь мы применили описанный выше фильтр и отправили результат через канал в команды tail и head. Они выбрали из данных предпоследнее значение.

wc: Подсчёт элементов в файлах

Команда wc (Word Count - подсчёт слов) используется для подсчёта числа строк и слов в файлах. Она также полезна для подсчёта байтов, символов и длины самой длинной строки. Её синтаксис:

 wc [опции] [файл(ы)]
Список полезных опций:

-l: вывод количества новых строк;

-w: вывод количества слов;

-m: вывод общего количества символов;

-c: вывод количества байт;

-L: вывод длины самой длинной строки в заданном тексте.

По умолчанию команда wc выводит количество новых строк, слов и символов. Вот несколько примеров использования:

Если нам нужно определить число пользователей в нашей системе, мы можем ввести:

 $wc -l /etc/passwd 
Если нам нужно узнать число CPU в нашей системе, мы пишем:

 $grep "model name" /proc/cpuinfo |wc -l
В предыдущем разделе мы получили список сообщений об успешно отправленных письмах на адреса, перечисленные в нашем файле./patterns.txt. Если нам нужно узнать количество таких сообщений, мы можем перенаправить наш отфильтрованный результат через канал в команду wc:

 # fgrep -f ./patterns.txt /var/log/mail/info | wc -l
sort: Сортировка содержимого файла

Ниже представлен синтаксис этой можно утилиты для сортировки[16]:

 sort [опции] [файл(ы)]
Давайте отсортируем часть файла /etc/passwd. Как видите сам по себе этот файл не отсортирован:

 $ cat /etc/passwd
Если нам нужно отсортировать его по полю login, мы набираем:

 $ sort /etc/passwd
По умолчанию команда sort сортирует информацию по первому полю в порядке возрастания (в нашем случае по полю login). Если нам нужно отсортировать данные в порядке убывания, мы используем опцию -r:

 $ sort -r /etc/passwd
Для каждого пользователья имеется свой собственный UID, записанный в файле /etc/passwd. Давайте отсортируем этот файл в порядке возрастания по полю UID:

 $ sort /etc/passwd -t":" -k3 -n
Здесь мы используем следующие опции sort:

-t":": сообщает sort'у, что разделителем полей является символ ":";

-k3: означает, что сортировка должна быть выполнена по по третьему столбцу;

-n: сообщает, что выполняется сортировка числовых данных, а не буквенных.

То же самое может быть выполнено в обратном порядке:

$ sort /etc/passwd -t":" -k3 -n -r
Обратите внимание, что sort обладает двумя важными опциями:

-u: строгая сортировка: исключаются повторяющиеся поля сортировки;

-f: игнорирование регистра (строчные символы обрабатываются так же, как и прописные).

И в заключение, если нам нужно найти пользователя с наивысшим UID, мы можем воспользоваться этой командой:

$ sort /etc/passwd -t":" -k3 -n |tail -n1
, где мы сортируем файл /etc/passwd в порядке возрастания по столбцу UID и прогоняем результат по каналу через команду tail, которая выводит первое значение из отсортированного списка.


[14] Некоторые примеры в этом разделе основаны на реальной работе с файлами журналов некоторых серверов (служб, демонов). Убедитесь, что у вас запущен syslogd (разрешает журналирование демонов), соответствующий демон (в нашем случае Postfix), и что вы в работаете под root'ом. И, естественно, вы всегда можете применять наши примеры к другим файлам.

[15] Например, файл /var/log/mail/info содержит информацию обо всех отправленных письмах, сообщениях о выборке почты пользователями по протоколу POP и т.д.

[16] Здесь мы только вкратце рассмотрим sort, потому что о её возможностях можно написать целую книгу.
